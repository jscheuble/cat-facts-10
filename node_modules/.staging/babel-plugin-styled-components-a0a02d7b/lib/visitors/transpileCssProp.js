"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperModuleImports = require("@babel/helper-module-imports");

var _detectors = require("../utils/detectors");

var _options = require("../utils/options");

// Most of this code was taken from @satya164's babel-plugin-css-prop
// @see https://github.com/satya164/babel-plugin-css-prop
var TAG_NAME_REGEXP = /^[a-z][a-z\d]*(\-[a-z][a-z\d]*)?$/;

var getName = function getName(node, t) {
  if (typeof node.name === 'string') return node.name;

  if (t.isJSXMemberExpression(node)) {
    return `${getName(node.object, t)}.${node.property.name}`;
  }

  throw path.buildCodeFrameError(`Cannot infer name from node with type "${node.type}". Please submit an issue at github.com/styled-components/babel-plugin-styled-components with your code so we can take a look at your use case!`);
};

var _default = function _default(t) {
  return function (path, state) {
    if (!(0, _options.useCssProp)(state)) return;
    if (path.node.name.name !== 'css') return;
    var program = state.file.path; // state.customImportName is passed through from styled-components/macro if it's used
    // since the macro also inserts the import

    var importName = state.customImportName || (0, _detectors.importLocalName)('default', state);
    var bindings = program.scope.bindings; // Insert import if it doesn't exist yet

    if (!importName || !bindings[importName.name] || !bindings[importName]) {
      (0, _helperModuleImports.addDefault)(path, 'styled-components', {
        nameHint: 'styled'
      });
      importName = t.identifier((0, _detectors.importLocalName)('default', state, true));
    }

    if (!t.isIdentifier(importName)) importName = t.identifier(importName);
    var elem = path.parentPath;
    var name = getName(elem.node.name, t);
    var id = path.scope.generateUidIdentifier('Styled' + name.replace(/^([a-z])/, function (match, p1) {
      return p1.toUpperCase();
    }));
    var styled;
    var injector;

    if (TAG_NAME_REGEXP.test(name)) {
      styled = t.callExpression(importName, [t.stringLiteral(name)]);
    } else {
      styled = t.callExpression(importName, [t.identifier(name)]);

      if (bindings[name] && !t.isImportDeclaration(bindings[name].path.parent)) {
        injector = function injector(nodeToInsert) {
          return (t.isVariableDeclaration(bindings[name].path.parent) ? bindings[name].path.parentPath : bindings[name].path).insertAfter(nodeToInsert);
        };
      }
    }

    var css;

    if (